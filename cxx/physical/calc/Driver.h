/** \file
 * Physical units math expression parser.
 */

/** \example calc/parser/testParser.cpp
 * Very basic example of using the physical quantity calculator
 * (runtime::physical::calc::Driver) to parse some simple expressions.
 *
 * This example should print on stdout:
   \verbatim
     <10 m>
     (3.33564e-08,0)
   \endverbatim
 */

/** \example calc/interactive/testInteractive.cpp
 * This example was originally intended to be a test program for the
 * calculator grammar engine, but has ended up being a fairly capable units
 * calculator.  It can function as a simple calculator with variables,
 * constants, and (at-compile-time-added) mathematical functions.
 *
 * Perhaps it might even rival with GNU units. :-)
 */

/** \example calc/advanced/testAdvanced.cpp
 * Demonstrates how the expression parser can be used to create an abstract
 * expression tree that can be evaluated at some later time and can depend on
 * valued modified external to the Parser.
 */

#ifndef physical_calc_Driver_h
#define physical_calc_Driver_h

#include <physical/runtime.h>
#include <physical/calc/symbol.h>
#include <physical/calc/detail/expression/Node.h>

#include <string>
#include <vector>

/** The physical namespace is used to encapsulate the three parser classes
 * physical::Parser, physical::Scanner and physical::Driver */
namespace runtime {
  namespace physical {
    namespace calc {

      namespace detail {
        /* forward declaration of location. */
        class location;
        class Scanner;
      }

      /** The Driver class brings together all components. It creates an instance of
       * the Parser and Scanner classes and connects them. Then the input stream is
       * fed into the scanner object and the parser gets it's token
       * sequence. Furthermore the driver object is available in the grammar rules as
       * a parameter. Therefore the driver class contains a reference to the
       * structure into which the parsed data is saved. */
      class Driver {
        /* TYPEDEFS */
      public:
        typedef std::vector<detail::expression::Node*> ExpressionVector;

      private:
        typedef ExpressionVector::iterator EIter;

        /* MEMBER STORAGE */
      private:
        /** The list of syntax errors that were found by the parser. */
        std::vector< std::pair<detail::location, std::string> > errors;

      public:
        /** enable debug output in the flex scanner. */
        bool trace_scanning;

        /** enable debug output in the bison parser. */
        bool trace_parsing;

        /** stream name (file or input stream) used for error messages. */
        std::string streamname;

        /** Pointer to the current lexer instance, this is used to connect the
         * parser to the scanner. It is used in the yylex macro. */
        detail::Scanner* lexer;

        /** The symbol table. */
        symbol::table symbols;

        /** Array of unevaluated, expression abstract syntax trees found by the
         * parser. */
        ExpressionVector expressions;



        /* MEMBER FUNCTIONS */
      public:
        /** Construct a new parser driver context. */
        Driver();

        /** Destructor clears away all expression abstract syntax trees. */
        ~Driver();

        /** Invoke the scanner and parser for a stream.
         * @param in        input stream
         * @param sname     stream name for error messages
         * @return          true if successfully parsed
         */
        bool parse( std::istream& in,
                    const std::string& sname = "stream input" );

        /** Invoke the scanner and parser on an input string.
         * @param input        input string
         * @param sname        stream name for error messages
         * @return             true if successfully parsed
         */
        bool parse( const std::string& input,
                    const std::string& sname = "string input" );

        /** Parse a stream, evaluate the expressions, and return the last result.
         * Any expression abstract syntax trees generated by the statements in the
         * input stream are evaluated and then removed from the expressions vector
         * before this function exits. 
         * @param in        input stream
         * @param sname     stream name for error messages
         * @return          The evaluation of the last statement
         */
        Quantity eval( std::istream& in,
                       const std::string& sname = "stream input" );

        /** Parse a stream, evaluate the expressions, and return the last result.
         * Any expression abstract syntax trees generated by the statements in the
         * input stream are evaluated and then removed from the expressions vector
         * before this function exits. 
         * @param in          input stream
         * @param q_units_out The units to which the output is converted.  (The
         *                    dimensions MUST match.)
         * @param sname       stream name for error messages
         * @return            The evaluation of the last statement in the units
         *                    of units_out
         */
        Quantity::coeff_type eval( std::istream& in,
                                   const Quantity & q_units_out,
                                   const std::string& sname = "stream input" );

        /** Parse a string, evaluate the expressions, and return the last result.
         * Any expression abstract syntax trees generated by the statements in the
         * input stream are evaluated and then removed from the expressions vector
         * before this function exits. 
         * @param input     input string
         * @param sname     stream name for error messages
         * @return          The evaluation of the last statement
         */
        Quantity eval( const std::string& input,
                       const std::string& sname = "string input" );

        /** Parse a string, evaluate the expressions, and return the last result.
         * Any expression abstract syntax trees generated by the statements in the
         * input stream are evaluated and then removed from the expressions vector
         * before this function exits. 
         * @param input       input stream
         * @param q_units_out The units to which the output is converted.  (The
         *                    dimensions MUST match.)
         * @param sname       stream name for error messages
         * @return            The evaluation of the last statement in the units
         *                    of units_out
         */
        Quantity::coeff_type eval( const std::string & input,
                                   const Quantity & q_units_out,
                                   const std::string& sname = "string input" );

        /** Parses and executes any commands in the given stream, ignoring any
         * results.  Any expression abstract syntax trees generated by the
         * statements in the input stream are evaluated and then removed from the
         * expressions vector before this function exits. 
         * @param in        input stream
         * @param sname     stream name for error messages
         */
        void exec( std::istream & in,
                   const std::string & sname = "exec input" );

        /** Parses and executes any commands in the given string, ignoring any
         * results.  Any expression abstract syntax trees generated by the
         * statements in the input string are evaluated and then removed from the
         * expressions vector before this function exits. 
         * @param input        input string
         * @param sname        stream name for error messages
         */
        void exec( const std::string & input,
                   const std::string & sname = "exec input" );

        /** Free all saved expression abstract syntax trees. */
        void clearExpressions() {
          const EIter end = expressions.end();
          for( EIter i = expressions.begin(); i != end; ++i ) {
            delete (*i);
          }

          /* doesn't really free space, but I think that should be fine. */
          expressions.clear();
        }

        /** Dump a list of (a subset) of all the symbols in the symbol table. */
        void dump( std::ostream & out,
                   const enum symbol::TYPE & typ
                      = symbol::UNDEFINED ) const;

        /** Add all units known to the registry into the symbol table. */
        void addPhysicalUnits();

        /** Add pre-defined set of math functions into the symbol table. */
        void addMathLib();

        // To demonstrate pure handling of parse errors, instead of
        // simply dumping them on the standard error output, we will pass
        // them to the driver using the following two member functions.

        /** Error handling with associated line number. This can be modified to
         * output the error e.g. to a dialog box. */
        void error( const detail::location& l, const std::string& m );


        /* STATIC FUNCTIONS */
        static Driver & instance();

      };

    }/* namespace physical::calc */



    /** Provide an istream operator, since we have a calculator Driver
     * available. */
    inline std::istream & operator>> ( std::istream & in,
                                       runtime::physical::Quantity & out ) {
      std::string s;
      char c = '\0';

      in.get(c);
      while ( in.good() && c && c != ';' && c != ',' && c != '\n' ) {
        s += c;
        in.get(c);
      }

      if ( in.good() && c && c != ';' && c != ',' && c != '\n' )
        in.putback(c);

      try {
        if ( s.size() > 0u ) {
          out = runtime::physical::calc::Driver::instance().eval( s );
          if ( in.eof() )
            in.clear( in.rdstate() ^ std::ios::eofbit ^ std::ios::failbit );
        } else {
          in.setstate( std::ios::eofbit | std::ios::failbit );
        }
      } catch ( const runtime::physical::exception & e ) {
        in.setstate( std::ios::badbit );
      }
      return in;
    }

  }/* namespace runtime::physical */
}/* namespace runtime */

#endif // physical_calc_Driver_h
